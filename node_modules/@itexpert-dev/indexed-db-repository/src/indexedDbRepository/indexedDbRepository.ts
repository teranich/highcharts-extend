import {
    ICrudRepositoryReadRequest,
    ICrudRepositoryReadResponse,
    IConnectorApi,
    ICrudRepositoryCreateResponse,
    ICrudRepositoryCreateRequest,
    ICrudRepositoryUpdateRequest,
    ICrudRepositoryUpdateResponse,
    ICrudRepositoryDeleteRequest,
    ICrudRepositoryDeleteResponse, ICrudRepositoryReadRequestFieldFormat
} from '@itexpert-dev/i-crud-repository'
import {isNullOrUndefined} from "@itexpert-dev/tiny-helpers";
import {Observable, Subject} from "rxjs";
import {ICrudRepositoryMetadataRequest} from "@itexpert-dev/i-crud-repository/dist/ICrudRepository/metadata/request/ICrudRepositoryMetadataRequest";
import {ICrudRepositoryMetadataResponse} from "@itexpert-dev/i-crud-repository/dist/ICrudRepository/metadata/response/ICrudRepositoryMetadataResponse";

export class BaseIndexedDBRepository implements IConnectorApi{
    protected dbName: string;
    protected dbVersion: number;

    protected constructorOnSuccessOpen(e: any){
        let db = (<IDBOpenDBRequest>e.target).result;
        db.close();
    }
    protected constructorOnUpgradeNeeded(e: any){
        console.log('need upgrade');
    }

    protected constructorOnError(e: any){
        console.log(`error: ${e}`);
    }

    constructor(dbName: string, dbVersion: number){
        this.dbName = dbName;
        this.dbVersion = dbVersion;
        if(!window.hasOwnProperty('indexedDB')){
            throw new Error('indexedDB not support')
        }
        let request = indexedDB.open(dbName, dbVersion);
        request.onsuccess = this.constructorOnSuccessOpen;
        request.onupgradeneeded = this.constructorOnUpgradeNeeded;
        request.onerror = this.constructorOnError;
    }

    protected connect():Observable<IDBDatabase>{
        let querySubject = new Subject();
        let request = indexedDB.open(this.dbName, this.dbVersion);
        request.onsuccess = (e)=>{
            let db = (<IDBOpenDBRequest>e.target).result;
            querySubject.next(db);
            querySubject.complete();
        };
        request.onerror = (e)=>{
            querySubject.error(`connect request error`);
            querySubject.complete();
        };

        return querySubject;
    }

    public create(query: ICrudRepositoryCreateRequest):Observable<ICrudRepositoryCreateResponse>{
        let eventSubject = new Subject();

        this.connect().subscribe(
            dbConnect=>{
                let transaction = dbConnect.transaction([query.entity], 'readwrite')
                    .objectStore(query.entity)
                    .add(query.data);

                transaction.onsuccess = (status) => {
                    let response:ICrudRepositoryCreateResponse = {
                        status:'success'
                    };
                    eventSubject.next(response);
                    eventSubject.complete();
                };
                transaction.onerror = (error) => {
                    let response:ICrudRepositoryCreateResponse = {
                        status: 'error',
                        message: transaction.error.toString()
                    };
                    eventSubject.error(response);
                    eventSubject.complete();
                }
            }
        );
        return eventSubject
    }

    public read(query:ICrudRepositoryReadRequest):Observable<ICrudRepositoryReadResponse>{
        let eventsSubject = new Subject();

        this.connect().subscribe(
            dbConnect=>{
                let transaction = dbConnect.transaction([query.entity], 'readonly');
                let objStore = transaction.objectStore(query.entity);

                if (isNullOrUndefined(query.filter)){
                    let hasLimit = isNullOrUndefined(query.limit);
                    let resultData:ICrudRepositoryReadResponse = {
                        data: [],
                        totalResult: null
                    };

                    let cursorStore = objStore.openCursor();
                    let currentOffset: number = 0;
                    cursorStore.onsuccess = event=>{
                        let target: any = event.target;
                        let cursor = target.result;
                        if(cursor!==null){
                            if((resultData.data as Array<any>).length < query.limit && query.offset <= currentOffset){
                                (resultData.data as Array<any>).push(cursor.value);
                            }else{}
                            currentOffset += 1;
                            cursor.continue();
                        }else{
                            resultData.totalResult = currentOffset;
                            eventsSubject.next(resultData);
                            eventsSubject.complete();
                        }
                    };
                } else{
                    if (
                        isNullOrUndefined(query.filter) ||
                        isNullOrUndefined(query.filter.nodes) ||
                        isNullOrUndefined((query.filter.nodes[0] as ICrudRepositoryReadRequestFieldFormat).value)
                    ){
                        eventsSubject.error(`first filter value is null ${JSON.stringify(query)}`);
                        eventsSubject.complete();
                    } else {
                        let fieldBlock: ICrudRepositoryReadRequestFieldFormat = (query.filter.nodes[0] as ICrudRepositoryReadRequestFieldFormat);
                        let index = objStore.index(fieldBlock.field);
                        index.get(fieldBlock.value)
                            .onsuccess = (e:any)=>{
                                eventsSubject.next({
                                    data: [e.target.result],
                                    totalResult: [e.target.result].length
                                });
                                eventsSubject.complete();
                            }
                    }

                }

            }
        );
        return eventsSubject
    }

    public update(query:ICrudRepositoryUpdateRequest):Observable<ICrudRepositoryUpdateResponse>{
        return new Subject();
    }
    public delete(query:ICrudRepositoryDeleteRequest):Observable<ICrudRepositoryDeleteResponse>{
        return new Subject();
    }

    public metadata(query: ICrudRepositoryMetadataRequest):Observable<ICrudRepositoryMetadataResponse>{
        let querySubject = new Subject();

        this.connect().subscribe(
            dbConnect=>{
                let transaction = dbConnect.transaction(['metadata'], 'readonly');
                let objStore = transaction.objectStore('metadata')
                    .index('entityName')
                    .get(query.entity)
                    .onsuccess = (e:any)=>{
                        let response: ICrudRepositoryMetadataResponse = {
                            verboseName: query.entity,
                            properties: e.target.result.meta
                        };

                        querySubject.next(response);
                        querySubject.complete();
                    }
            }
        )

        return querySubject;
    }
}