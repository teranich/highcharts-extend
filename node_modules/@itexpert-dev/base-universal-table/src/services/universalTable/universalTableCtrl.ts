import {IUniversalTableCtrlInitParams} from "./common/interfaces/IUniversalTableCtrlInitParams";
import {IUniversalTableGetDataRequest} from "./common/interfaces/IUniversalTableGetDataRequest";
import {IUniversalTableGetDataResponse} from "./common/interfaces/IUniversalTableGetDataResponse";
import {IUniversalTableState} from "./common/interfaces/IUniversalTableState";
import {IUniversalTableViewScope} from "./common/interfaces/IUniversalTableViewScope";
import {IUniversalTableComponents} from "./baseUniversalTableConfigurator/interfaces/IUniversalTableDefaultComponents";
import {KeyValueStorage} from '@itexpert-dev/key-value-storage'
import {Observable, Subject, ReplaySubject} from 'rxjs'
import {UniversalTableDataPreprocessors} from './universalTableDataPreprocessors'
import {IUniversalTableParsedRequest} from "./common/interfaces/IUniversalTableParsedRequest";
import {UniversalTableConfigurator} from "./baseUniversalTableConfigurator/baseUniversalTableConfigurator";

class UniversalTableCtrl{
    private headers: Subject<IUniversalTableParsedRequest> = new ReplaySubject<IUniversalTableParsedRequest>(1);
    private rows: Subject<IUniversalTableParsedRequest> = new ReplaySubject<IUniversalTableParsedRequest>(1);

    /**
     * @desc object for ui bind handlers and templates
     * @type {IUniversalTableViewScope}
     */
    public viewScope:IUniversalTableViewScope = {
        headers: this.headers.map(next=>this.dataPreprocessors.parseHeaders(next.viewFields, next.metadata)),
        rows: this.rows.map(next=>this.dataPreprocessors.parseData(next.viewFields, next)),
        totalResult: 0
    };
    public currentState: IUniversalTableState;
    public stateStream: Subject<IUniversalTableState> = new ReplaySubject<IUniversalTableState>(1);

    /**
     * @desc ctrl instance components for render UI
     * @type {IUniversalTableComponents}
     */
    public tableComponents: IUniversalTableComponents = {};

    //storage for refs in template for inject components
    public viewContainerRefs:KeyValueStorage<any> = new KeyValueStorage<any>();

    public dataPreprocessors = UniversalTableDataPreprocessors;

    constructor(
        public initParams: IUniversalTableCtrlInitParams,
        public config: UniversalTableConfigurator
    ){
        this.currentState = {};
        this.stateStream.subscribe(
            next=>{
                Object.assign(this.currentState, next);
            }
        );
        this.updateCurrentState({isInit: false});

        //fix empty components map
        if(!this.initParams.hasOwnProperty('componentsMap')){
            this.initParams.componentsMap = {}
        }
        //apply local config by default and init config
        Object.assign(
            this.tableComponents,
            this.config.getDefaultComponents(),
            this.initParams.componentsMap
        );
        Object.assign(
            this.currentState,
            this.config.getDefaultInitTableState(),
            this.initParams.initState
        );
    }

    private updateCurrentState(state: IUniversalTableState){
        this.stateStream.next(Object.assign({}, this.currentState, state));
    }

    public resolveInit(){
        this.updateCurrentState({isInit: true});
    };

    private getRequireFields(state:IUniversalTableState, request: IUniversalTableGetDataResponse):string[]{
        let requireFields: string[];
        if (!state.hasOwnProperty('viewFields') || state.viewFields === null){
            if (!state.hasOwnProperty('fields') || state.fields === null){
                if (this.currentState === null || !this.currentState.hasOwnProperty('fields')){
                    requireFields = [];
                    Object.keys(request.metadata).map(
                        key=>requireFields.push(key)
                    )
                } else{
                    requireFields = this.currentState.fields
                }
            }else{
                requireFields = state.fields
            }
        } else {
            requireFields = state.viewFields
        }

        return requireFields
    }

    public updateState(
        state: IUniversalTableState = {},
        options:{enableStateDiff: boolean} = {enableStateDiff: true}
    ):Observable<null>{
        let newState: IUniversalTableState = {};
        if(options.enableStateDiff === true){
            let diff: IUniversalTableState = {};
            let anyDiff:boolean = false;
            Object.entries(state).map(
                ([key,val])=>{
                    if((this.currentState as any)[key]!==val){
                        anyDiff = true;
                        (diff as any)[key] = val
                    }
                }
            );
            if(anyDiff){
                return this.setState(Object.assign({}, this.currentState, diff))
            }else{
                return Observable.empty()
            }
        }else{
            Object.assign(newState, this.currentState, state);
        }

        return this.setState(newState)
    }

    private setState(state: IUniversalTableState):Observable<null>{
        this.updateCurrentState({isUpdate: true});
        let query:IUniversalTableGetDataRequest = {
            fields: state.fields,
            filter: state.filter,
            limit: state.limit,
            offset: state.offset,
            sort: state.sort
        };

        return this.initParams
            //send request to server
            .getDataMethod(query)
            //append state to query with actual totalResult
            .map(next=>{
                return Object.assign(next, {
                    state: Object.assign(state, {
                        totalResult: next.totalResult
                    })
                })
            })
            // calculate actual view fields
            .map(next=>{
                let result: IUniversalTableParsedRequest = Object.assign(next, {
                    viewFields: this.getRequireFields(next.state, next)
                });
                return result
            })
            // publish new data to UI binding stream
            .do((next)=>{
                this.headers.next(next);
                this.rows.next(next);
                this.updateCurrentState(Object.assign(next.state, {isUpdate: false}));
            })
            .pluck('state')
    }
}

export {
    UniversalTableCtrl,
    IUniversalTableCtrlInitParams,
    IUniversalTableViewScope,
    IUniversalTableState,
    UniversalTableConfigurator
}