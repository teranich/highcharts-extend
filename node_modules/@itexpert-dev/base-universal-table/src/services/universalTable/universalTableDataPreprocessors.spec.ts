import {UniversalTableDataPreprocessors} from './universalTableDataPreprocessors'
import {IDictionary} from "@itexpert-dev/i-dictionary";
import {IUniversalTableFieldMetadata} from "./common/interfaces/IUniversalTableFieldMetadata";
import {IUniversalTableGetDataResponse} from "./common/interfaces/IUniversalTableGetDataResponse";
import {IUniversalTableViewRow} from "./common/interfaces/IUniversalTableViewRow";

describe('test case for data preprocessors for parse server request to UI data format', ()=>{
    const viewFields: Array<string> = ['a', 'b', 'c'];
    const reorderViewFields: Array<string> = ['c', 'a', 'b'];

    describe('tests for baseHeaders preprocessor', ()=>{

        const aVerboseName = 'aVerbName';
        const bVerboseName = 'bVerbName';
        const cVerboseName = 'cVerbName';

        const metadataMock: IDictionary<IUniversalTableFieldMetadata> = {
            'a': {
                type: 'any',
                verboseName: aVerboseName
            },
            'b': {
                type: 'any2',
                verboseName: bVerboseName
            },
            'c': {
                type: 'any3',
                verboseName: cVerboseName
            }
        };

        it('easy test for baseHeaders preprocessor', ()=>{
            let headerPreprocessorResult = UniversalTableDataPreprocessors.parseHeaders(viewFields, metadataMock);
            expect(headerPreprocessorResult).toEqual([{label: aVerboseName}, {label: bVerboseName}, {label: cVerboseName}])
        });

        it('test for reorder fields', ()=>{
            let result = UniversalTableDataPreprocessors.parseHeaders(reorderViewFields, metadataMock);
            expect(result).toEqual([{label: cVerboseName}, {label: aVerboseName}, {label: bVerboseName}])
        });

        it('test for throw error if no field in metadata', ()=>{
            const metadata: IDictionary<IUniversalTableFieldMetadata> = {
                'c': {
                    type: 'any4',
                    verboseName: 'lol'
                }
            };

            expect(()=>{
                UniversalTableDataPreprocessors.parseHeaders(['a', 'b'], {})
            }).toThrowError(`fields: [a, b] not found in metadata\ncurrent metadata: ${metadata}`)
        })
    });
    describe('tests for data preprocessor', ()=>{
        const firstCellAVal = 'first baseCell A value';

        const cellAType = 'any baseCell type #1';

        const testResponse: IUniversalTableGetDataResponse = {
            data: [{
                'a': {
                    value: firstCellAVal
                }
            }],
            metadata: {
                'a': {
                    type: cellAType,
                    verboseName: 'baseCell a verbose name'
                }
            },
            totalResult: 1
        };

        const expectedResult: Array<IUniversalTableViewRow> = [{
            cells: [{
                value: firstCellAVal,
                type: cellAType
            }]
        }];

        it('easy test', ()=>{
            let result = UniversalTableDataPreprocessors.parseData(['a'], testResponse);
            expect(result).toEqual(expectedResult);
        });

        it('test if field missing in any row', ()=>{
            //TODO: add test
        });

        it('test if field missing in metadata', ()=>{
            //TODO: add test
        });

        it('test if field missing', ()=>{
            //TODO: add test, uncomment text under
            // let extendTestResponse = Object.assign({}, testResponse);
            // extendTestResponse.data.push(extendTestResponse.data[1]);
            // expect(()=>{
            //     UniversalTableDataPreprocessors.parseData(['a', 'b'], testResponse)
            // }).toThrowError(`fields: [b] not found in metadata\ncurrent metadata: ${testResponse.metadata}\nfields: [b] not found in data row: 1\nfields: [b] not found in data row: 2`)
        })
    })
});